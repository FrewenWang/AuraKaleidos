//
// Created by Frewen.Wang on 25-2-27.
//
#include<vector>

using namespace std;

class Solution {
public:
  /**
  * 这个问题的思路比较简单
  * 因为交易次数不受限，如果可以把所有的上坡全部收集到，一定是利益最大化的
  */
  //  int maxProfit(vector<int>& prices) {
  //    int result = 0;
  //    int len = prices.size();
  //    for(int i=1;i<len;i++) {
  //       if(prices[i] > prices[i-1]) {
  //         result += prices[i] - prices[i-1];
  //       }
  //    }
  //    return result;
  //  }

  int maxProfit(vector<int>& prices) {
     int ans = 0;
     int l=0,r=0;
     int profit = Integer.
  }

};