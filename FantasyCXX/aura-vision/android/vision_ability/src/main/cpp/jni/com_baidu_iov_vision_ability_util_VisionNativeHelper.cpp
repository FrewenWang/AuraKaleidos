/* DO NOT EDIT THIS FILE - it is machine generated */
#include <cmath>
#include <cstdio>
#include <map>
#include <memory>
#include <string>
#include <sys/time.h>
#include <unordered_map>
#include <vector>

#include "android/log.h"
#include "android/asset_manager_jni.h"
#include "jni.h"
#include "zconf.h"

#include "vision/VisionAbility.h"

#ifdef __cplusplus
extern "C" {
#endif

using namespace vision;

static const char* TAG = "VisionJni";
static const char *g_jni_class = "com/baidu/iov/vision/ability/util/VisionNativeHelper";
static const char *g_perf_class = "com/baidu/iov/vision/ability/util/PerformanceUtil";

static std::unordered_map<int, std::shared_ptr<VisionService>> g_va_service_map;
static std::unique_ptr<VisionInitializer> g_va_initializer;
static std::unordered_map<int, VisionRequest *> g_vision_request_map;
static std::unordered_map<int, VisionResult *> g_vision_result_map;
static std::unordered_map<int, VisionRequest *> g_single_request_map;
static std::unordered_map<int, VisionResult *> g_single_result_map;
static jmethodID g_add_item_mid = nullptr;
static bool g_init_success = false;

namespace {
void get_perf_from_native_to_java(JNIEnv *env, jobject oPrefUtil,
                                  std::map<std::string, std::uint64_t> &perf_map) {
    if (g_add_item_mid == nullptr) {
        jclass perf_cls = env->FindClass(g_perf_class);
        g_add_item_mid = env->GetMethodID(perf_cls, "addItem", "(Ljava/lang/String;J)V");
    }
    for (auto it = perf_map.begin(); it != perf_map.end(); ++it) {
        env->CallVoidMethod(oPrefUtil, g_add_item_mid, env->NewStringUTF(it->first.c_str()),
                            (jlong) it->second);
    }
}
} // namespace

void initModel(JNIEnv *env, jclass clazz, jobject assetManager) {
    if (g_init_success) {
        VLOGW(TAG, "SDK has already been initialized!");
        return;
    }
    // g_va_initializer = std::make_unique<VisionInitializer>();
    g_va_initializer.reset(new VisionInitializer());

#if !USE_EXTERNAL_MODEL
    g_va_initializer->init();
#else
    VLOGI(TAG, "load model from external file");
    auto* asset_manager = AAssetManager_fromJava(env, assetManager);
    auto* model_asset = AAssetManager_open(asset_manager, "model/vision_model_36t2.bin", AASSET_MODE_BUFFER);
    auto* model_data = (unsigned char *) AAsset_getBuffer(model_asset);
    auto model_len = static_cast<int>(AAsset_getLength(model_asset));
    g_va_initializer->init_from_memory(model_data, model_len);
#endif    
    g_init_success = true;
}

void initService(JNIEnv *env, jclass clazz, jint index) {
    if (g_va_service_map.find(index) == g_va_service_map.end()) {
        g_va_service_map[index] = std::make_shared<VisionService>();
    }
    g_va_service_map[index]->init();
    g_va_service_map[index]->set_config(USE_INTERNAL_MEM, VA_TO_FLOAT(false));

    g_vision_request_map[index] = g_va_service_map[index]->make_request();
    g_vision_result_map[index] = g_va_service_map[index]->make_result();
}

void initFaceBuffer(JNIEnv *env, jclass clazz, jint index, jobjectArray infos, jint count) {
    if (infos == nullptr || g_va_service_map.find(index) == g_va_service_map.end()) {
        VLOGE(TAG, "initFaceBuffer Error, sdk has not been initialized yet");
        return;
    }
    g_va_service_map[index]->set_config(FACE_MAX_COUNT, VA_TO_FLOAT(count));
    auto* result = g_vision_result_map[index]->getFaceResult();
    result->resize(count);
    for (int i = 0; i < count; i++) {
        jobject buffer = (jobject) env->GetObjectArrayElement(infos, i);
        result->faceInfos[i] = (FaceInfo *) env->GetDirectBufferAddress(buffer);;
    }
}

void initGestureBuffer(JNIEnv *env, jclass clazz, jint index, jobjectArray infos, jint count) {
    if (infos == nullptr || g_va_service_map.find(index) == g_va_service_map.end()) {
        VLOGE(TAG, "initGestureBuffer Error, sdk has not been initialized yet");
        return;
    }
    g_va_service_map[index]->set_config(GESTURE_MAX_COUNT, VA_TO_FLOAT(count));
    auto* result = g_vision_result_map[index]->getGestureResult();
    result->resize(count);
    for (int i = 0; i < count; i++) {
        jobject buffer = (jobject) env->GetObjectArrayElement(infos, i);
        result->gestureInfos[i] = (GestureInfo *) env->GetDirectBufferAddress(buffer);;
    }
}

void initBodyBuffer(JNIEnv *env, jclass clazz, jint index, jobjectArray infos, jint count) {
    if (infos == nullptr || g_va_service_map.find(index) == g_va_service_map.end()) {
        VLOGE(TAG, "initHumanPoseBuffer Error, sdk has not been initialized yet");
        return;
    }
    g_va_service_map[index]->set_config(BODY_MAX_COUNT, VA_TO_FLOAT(count));
    auto *result = g_vision_result_map[index]->getBodyResult();
    result->resize(count);
    for (int i = 0; i < count; i++) {
        jobject buffer = (jobject) env->GetObjectArrayElement(infos, i);
        result->pBodyInfos[i] = (BodyInfo *) env->GetDirectBufferAddress(buffer);
    }
}

void initFrameBuffer(JNIEnv *env, jclass clazz, jint index, jobject info) {
    if (info == nullptr || g_va_service_map.find(index) == g_va_service_map.end()) {
        VLOGE(TAG, "initFrameBuffer Error, sdk has not been initialized yet");
        return;
    }
    g_vision_result_map[index]->setFrameInfo((FrameInfo *) env->GetDirectBufferAddress(info));
}

[[deprecated("use initModel(...) instead")]]
void init(JNIEnv *env, jclass clazz, jint index, jstring configJson, jobject assetManager,
          jobjectArray faceInfos, jint faceMaxCount,
          jobjectArray gestureInfos, jint gestureMaxCount,
          jobjectArray bodyInfos, jint bodyInfoMaxCount,
          jobject frameInfo) {
    if (g_init_success) {
        VLOGW(TAG, "SDK has already been initialized!");
        return;
    }

    if (g_va_service_map.find(index) == g_va_service_map.end()) {
        g_va_service_map[index] = std::make_shared<VisionService>();
    }
#if !USE_EXTERNAL_MODEL
    g_va_service_map[index]->init();
#else
    const char* model_path = "model/vision_model.bin";
    switch (VA_TO_INT(RtConfig::get_config(PRODUCT_NUMBER))) {
        case ProductNumber::MAINLINE:{
            model_path = "model/vision_model.bin";
            break;
        }
        case ProductNumber::CHERY_32T:{
            model_path = "model/vision_model_32t.bin";
            break;
        }
        case ProductNumber::CHERY_36T2: {
            model_path = "model/vision_model_36t2.bin";
            break;
        }
        default:{
            model_path = "model/vision_model.bin";
        }
    }
    auto* g_asset_manager = AAssetManager_fromJava(env, assetManager);
    auto* g_model_asset = AAssetManager_open(g_asset_manager, model_path, AASSET_MODE_BUFFER);
    auto* g_model = (unsigned char *) AAsset_getBuffer(g_model_asset);
    auto model_len = static_cast<int>(AAsset_getLength(g_model_asset));
    g_va_service_map[index]->init_from_memory(g_model, model_len);
#endif

    g_va_service_map[index]->set_config(USE_INTERNAL_MEM, VA_TO_FLOAT(false));
    g_va_service_map[index]->set_config(FACE_MAX_COUNT, VA_TO_FLOAT(faceMaxCount));
    g_va_service_map[index]->set_config(GESTURE_MAX_COUNT, VA_TO_FLOAT(gestureMaxCount));
    g_va_service_map[index]->set_config(BODY_MAX_COUNT, VA_TO_FLOAT(bodyInfoMaxCount));

    g_vision_request_map[index] = g_va_service_map[index]->make_request();
    g_vision_result_map[index] = g_va_service_map[index]->make_result();
    if (faceInfos != nullptr) {
        FaceResult *face_result = g_vision_result_map[index]->getFaceResult();
        for (int i = 0; i < faceMaxCount; i++) {
            jobject face_info = (jobject) env->GetObjectArrayElement(faceInfos, i);
            void *face = env->GetDirectBufferAddress(face_info);
            face_result->faceInfos[i] = (FaceInfo *) face;
        }
    }
    if (gestureInfos != nullptr) {
        GestureResult *gesture_result = g_vision_result_map[index]->getGestureResult();
        for (int i = 0; i < gestureMaxCount; i++) {
            jobject gesture_info = (jobject) env->GetObjectArrayElement(gestureInfos, i);
            void *gesture = env->GetDirectBufferAddress(gesture_info);
            gesture_result->gestureInfos[i] = (GestureInfo *) gesture;
        }
    }

    // 进行肢体检测
    if (bodyInfos != nullptr) {
        BodyResult *body_result = g_vision_result_map[index]->getBodyResult();
        for (int i = 0; i < bodyInfoMaxCount; i++) {
            jobject body_info = (jobject) env->GetObjectArrayElement(bodyInfos, i);
            void *body = env->GetDirectBufferAddress(body_info);
            body_result->pBodyInfos[i] = (BodyInfo *) body;
        }
    }
    if (frameInfo != nullptr) {
        void *frame = env->GetDirectBufferAddress(frameInfo);
        FrameInfo *frame_result = g_vision_result_map[index]->getFrameInfo();
        frame_result = (FrameInfo *) frame;
    }

    g_init_success = true;
}

jboolean detect(JNIEnv *env, jclass clazz, jint index, jbyteArray frame, jobject oPrefUtil) {
    if (!g_init_success || frame == nullptr) {
        return JNI_FALSE;
    }

    g_vision_request_map[index]->clear();
    g_vision_request_map[index]->frame = (unsigned char *) (env->GetByteArrayElements(frame,
                                                                                       JNI_FALSE));
    g_va_service_map[index]->detect(g_vision_request_map[index], g_vision_result_map[index]);

#ifdef ENABLE_PERF
    get_perf_from_native_to_java(env, oPrefUtil, g_vision_result_map[index]->get_perf_util()->get_records());
#endif

    return JNI_TRUE;
}

jboolean detect_with_index(JNIEnv *env, jclass clazz, jint index, jbyteArray frame, jobject oPrefUtil) {
    if (!g_init_success || frame == nullptr) {
        return JNI_FALSE;
    }

    g_vision_request_map[index]->clear();
    g_vision_request_map[index]->frame = (unsigned char *) (env->GetByteArrayElements(frame, JNI_FALSE));
    g_va_service_map[index]->detect(g_vision_request_map[index], g_vision_result_map[index]);

#ifdef ENABLE_PERF
    get_perf_from_native_to_java(env, oPrefUtil, g_vision_result_map[index]->get_perf_util()->get_records());
#endif

    return JNI_TRUE;
}

jboolean detect_with_index_frame_size(JNIEnv *env, jclass clazz, jint index, jbyteArray frame,
                                      jint frameWidth,
                                      jint frameHeight, jobject oPrefUtil) {
    if (!g_init_success || frame == nullptr) {
        return JNI_FALSE;
    }

    g_vision_request_map[index]->clear();
    g_vision_request_map[index]->frame = (unsigned char *) (env->GetByteArrayElements(frame,
                                                                                       JNI_FALSE));
    g_vision_request_map[index]->width = frameWidth;
    g_vision_request_map[index]->height = frameHeight;
    g_va_service_map[index]->detect(g_vision_request_map[index], g_vision_result_map[index]);

#ifdef ENABLE_PERF
    get_perf_from_native_to_java(env, oPrefUtil, g_vision_result_map[index]->get_perf_util()->get_records());
#endif
    return JNI_TRUE;
}

[[deprecated("use detect(...) instead")]]
jboolean detect_with_buffer(JNIEnv *env, jclass clazz, jint index, jbyteArray frame,
                            jfloatArray faceInfos, jobjectArray gestureInfos, jfloatArray frameInfo,
                            jobject oPrefUtil) {
    if (!g_init_success || frame == nullptr) {
        return JNI_FALSE;
    }

    auto* face_result = g_vision_result_map[index]->getFaceResult();
    jfloat *face_info = env->GetFloatArrayElements(faceInfos, JNI_FALSE);
    face_result->faceInfos[0] = (FaceInfo *) face_info;

    GestureResult *gesture_result = g_vision_result_map[index]->getGestureResult();
    for (int i = 0; i < VA_TO_INT(g_va_service_map[index]->get_config(GESTURE_MAX_COUNT)); i++) {
        jfloatArray gesture_info = (jfloatArray) env->GetObjectArrayElement(gestureInfos, i);
        jfloat *gi = env->GetFloatArrayElements(gesture_info, JNI_FALSE);
        gesture_result->gestureInfos[i] = (GestureInfo *) gi;
    }

    jfloat *frame_info = env->GetFloatArrayElements(frameInfo, JNI_FALSE);
    g_vision_result_map[index]->setFrameInfo((FrameInfo *) frame_info);

    g_vision_request_map[index]->clear();
    g_vision_request_map[index]->frame = (unsigned char *) (env->GetByteArrayElements(frame, JNI_FALSE));
    g_va_service_map[index]->detect(g_vision_request_map[index], g_vision_result_map[index]);

#ifdef ENABLE_PERF
    get_perf_from_native_to_java(env, oPrefUtil, g_vision_result_map[index]->get_perf_util()->get_records());
#endif
    /**
     * [Note] There wasn't new/malloc operate, so no need invoke env->Release func,
     *        it will cause "/dev/ashmem/dalvik-main space (region space) (deleted)",
     *        when you focus on the proc/pid/maps or the other perf-tools, memory-churn because of env->release frequently.
     */
    return JNI_TRUE;
}

jboolean detect_single_function_with_buffer(JNIEnv *env, jclass clazz, jint index, jint type, jbyteArray frame,
        jobjectArray faceInfos, jint faceMaxCount, jobject frameInfo) {
    if (!g_init_success || frame == nullptr || faceInfos == nullptr) {
        return JNI_FALSE;
    }

    if (g_single_request_map.find(index) == g_single_request_map.end()) {
        g_single_request_map[index] = g_va_service_map[index]->make_request();
    }

    if (g_single_result_map.find(index) == g_single_result_map.end()) {
        g_single_result_map[index] = g_va_service_map[index]->make_result();
    }

    FaceResult *face_result = g_single_result_map[index]->get_face_result();
    face_result->resize(faceMaxCount);
    for (int i = 0; i < faceMaxCount; ++i) {
        jobject face_info = (jobject) env->GetObjectArrayElement(faceInfos, i);
        void *face = env->GetDirectBufferAddress(face_info);
        face_result->_face_infos[i] = (FaceInfo *)face;
    }

    if (frameInfo != nullptr) {
        void *frame_info = env->GetDirectBufferAddress(frameInfo);
        g_single_result_map[index]->setFrameInfo((FrameInfo*)frame_info);
    }

    g_single_request_map[index]->set_specific_ability(static_cast<AbilityId>(type));
    g_single_request_map[index]->frame = (unsigned char *) (env->GetByteArrayElements(frame, JNI_FALSE));

    g_va_service_map[index]->detect(g_single_request_map[index], g_single_result_map[index]);
    return JNI_TRUE;
}

[[deprecated("use detect_single_function_with_buffer instead")]]
void init_single_data(JNIEnv *env, jclass clazz, jint index,
                      jobjectArray faceInfos, jint faceMaxCount, jobject frameInfo) {
    if (g_single_request_map.find(index) == g_single_request_map.end()) {
        g_single_request_map[index] = g_va_service_map[index]->make_request();
    } else {
        g_single_request_map[index]->clear_all();
    }
    if (g_single_result_map.find(index) == g_single_result_map.end()) {
        g_single_result_map[index] = g_va_service_map[index]->make_result();
    } else {
        g_single_result_map[index]->clear_all();
    }

    if (faceInfos != nullptr && frameInfo != nullptr) {
        FaceResult *face_result = g_single_result_map[index]->get_face_result();
        for (int i = 0; i < faceMaxCount; ++i) {
            jobject face_info = (jobject) env->GetObjectArrayElement(faceInfos, i);
            void *face = env->GetDirectBufferAddress(face_info);
            face_result->_face_infos[i] = (FaceInfo *) face;
        }

        void *frame_info = env->GetDirectBufferAddress(frameInfo);
        g_single_result_map[index]->setFrameInfo((FrameInfo *) frame_info);
    }
}

[[deprecated("use detect_single_function_with_buffer instead")]]
jboolean detect_single_function(JNIEnv *env, jclass clazz, jint index, jint type, jbyteArray frame,
                                jfloatArray landmarks) {
    if (!g_init_success || frame == nullptr || landmarks == nullptr) {
        return JNI_FALSE;
    }

    g_vision_request_map[index]->set_specific_ability(static_cast<AbilityId>(type));
    g_vision_request_map[index]->_frame = (unsigned char *) (env->GetByteArrayElements(
            frame, JNI_FALSE));

    auto *face = g_vision_result_map[index]->getFaceResult();
    auto *lmk = (vision::VPoint * )(env->GetFloatArrayElements(landmarks, JNI_FALSE));
    memcpy(face->faceInfos[0]->landmark2D106, lmk,
           static_cast<size_t>(FaceInfo::LANDMARK_2D_106_LENGTH));

    g_va_service_map[index]->detect(g_vision_request_map[index],
                                    g_vision_result_map[index]);
    return JNI_TRUE;
}

float compare_face_features(JNIEnv *env, jclass clazz, jfloatArray first, jfloatArray second) {
    jfloat *first_feature = env->GetFloatArrayElements(first, JNI_FALSE);
    jfloat *second_feature = env->GetFloatArrayElements(second, JNI_FALSE);

    float result = FaceIdUtil::compare_face_features(first_feature, second_feature);

    env->ReleaseFloatArrayElements(first, first_feature, JNI_FALSE);
    env->ReleaseFloatArrayElements(second, second_feature, JNI_FALSE);

    return result;
}

jboolean get_switch(JNIEnv *env, jclass clazz, jint index, jshort ability) {
    return static_cast<jboolean>(g_va_service_map[index]->get_switch(ability));
}

void get_switches(JNIEnv *env, jclass clazz, jint index, jobject ability_map) {
    jclass c_map = env->GetObjectClass(ability_map);
    jmethodID m_put = env->GetMethodID(c_map, "put",
                                       "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");

    jclass c_short = env->FindClass("java/lang/Short");
    jmethodID m_short = env->GetMethodID(c_short, "<init>", "(S)V");

    jclass c_bool = env->FindClass("java/lang/Boolean");
    jmethodID m_bool = env->GetMethodID(c_bool, "<init>", "(Z)V");

    auto switches = g_va_service_map[index]->get_switches();
    for (auto it = switches.begin(); it != switches.end(); ++it) {
        jobject key = env->NewObject(c_short, m_short, it->first);
        jobject val = env->NewObject(c_bool, m_bool, it->second);
        env->CallObjectMethod(ability_map, m_put, key, val);
    }
}

jboolean set_switch(JNIEnv *env, jclass clazz, jint index, jshort ability, jboolean switcher) {
    g_va_service_map[index]->set_switch(ability, switcher);
    return JNI_TRUE;
}

[[deprecated("use set_switch(...) instead")]]
void set_switches(JNIEnv *env, jclass clazz, jobject ability_map) {
    // TODO: 实现麻烦
    VLOGW(TAG, "set_switches(...) is not implemented yet!");
}

jboolean set_config(JNIEnv *env, jclass clazz, jint index, jint key, jfloat value) {
    g_va_service_map[index]->set_config(key, value);
    return JNI_TRUE;
}

float get_config(JNIEnv *env, jclass clazz, jint index, jint key) {
    return g_va_service_map[index]->get_config(key);
}

void clean_ability_trigger_accumulative(JNIEnv *env, jclass clazz, jint index, jshort ability) {
    g_va_service_map[index]->clean_ability_trigger_accumulative(ability);
}

void release(JNIEnv *env, jclass clazz, jint index) {
    if (g_va_service_map.find(index) == g_va_service_map.end()) {
        return;
    }
    g_va_service_map[index]->recycle_request(g_vision_request_map[index]);
    g_va_service_map[index]->recycle_result(g_vision_result_map[index]);
    g_va_service_map[index]->recycle_request(g_single_request_map[index]);
    g_va_service_map[index]->recycle_result(g_single_result_map[index]);

    g_va_service_map.erase(index);
    g_vision_request_map.erase(index);
    g_vision_result_map.erase(index);
    g_single_request_map.erase(index);
    g_single_result_map.erase(index);

    if (g_va_service_map.empty()) {
        g_va_initializer->deinit();
        g_init_success = false;
    }
}

[[deprecated("use set_config(...) instead")]]
jboolean set_init_config(JNIEnv *env, jclass clazz, jint index, jint key, jfloat value) {
    g_va_service_map[index]->set_config(key, value);
    return JNI_TRUE;
}

[[deprecated("use get_config(...) instead")]]
float get_init_config(JNIEnv *env, jclass clazz, jint index, jint key) {
    return g_va_service_map[index]->get_config(key);
}

int crop_face(JNIEnv *env, jclass clazz, jfloatArray landmark, jbyteArray data, jshort w,
                     jshort h, jshort desirew, jshort desireh, jbyteArray frameresize) {
    unsigned char *framedata = (unsigned char *) (env->GetByteArrayElements(data, JNI_FALSE));
    unsigned char *frameresizedata = (unsigned char *) (env->GetByteArrayElements(frameresize,
                                                                                  JNI_FALSE));
    jfloat *landmarks = env->GetFloatArrayElements(landmark, JNI_FALSE);
    return FaceIdUtil::crop_face(landmarks, framedata, w, h, desirew, desireh,
                                           frameresizedata);
}

bool recent_update_feature(JNIEnv *env, jclass clazz, jfloatArray src, jfloatArray cur, jfloatArray output) {
    float *p_src = (float *) (env->GetFloatArrayElements(src, JNI_FALSE));
    float *p_cur = (float *) (env->GetFloatArrayElements(cur, JNI_FALSE));
    float *p_output = (float *) (env->GetFloatArrayElements(output, JNI_FALSE));

    FaceIdUtil::update_face_feature(p_src, p_cur, p_output);
    env->SetFloatArrayRegion(output, 0, 1024, p_output);
}

void to_bytes(JNIEnv *env, jclass clazz, jfloatArray src_data, jbyteArray dest_data) {
    jfloat *datas = env->GetFloatArrayElements(src_data, nullptr);
    int size = env->GetArrayLength(src_data);
    jbyte *bytes = reinterpret_cast<jbyte *>(datas);
    size <<= 2;
    env->SetByteArrayRegion(dest_data, 0, size, bytes);
}

void to_floats(JNIEnv *env, jclass clazz, jbyteArray src_data, jfloatArray dest_data) {
    jbyte *datas = env->GetByteArrayElements(src_data, nullptr);
    int size = env->GetArrayLength(src_data);
    jfloat *floats = reinterpret_cast<jfloat *>(datas);
    size >>= 2;
    env->SetFloatArrayRegion(dest_data, 0, size, floats);
}

void yuv_to_rgb(JNIEnv *env, jclass clazz, jbyteArray src_data, jintArray dest_data, jint width,
                jint height) {
    unsigned char *src = (unsigned char *) (env->GetByteArrayElements(src_data, JNI_FALSE));
    int *dst = env->GetIntArrayElements(dest_data, JNI_FALSE);
    VisionUtil::yuv_to_rgb(src, dst, static_cast<int>(width), static_cast<int>(height));
}

void save_image(JNIEnv *env, jclass clazz, jstring savePath, jbyteArray src_data, jint width,
                jint height) {
    const char *path = env->GetStringUTFChars(savePath, 0);
    if (path == nullptr) {
        return;
    }

    char *frame = (char *) (env->GetByteArrayElements(src_data, JNI_FALSE));
    if (frame == nullptr || (width <= 0 && height <= 0)) {
        return;
    }

    VisionUtil::save_image(path, frame, static_cast<int>(width), static_cast<int>(height));
}

void face_angle_optimal(JNIEnv *env, jclass clazz, jfloatArray angle_a, jfloatArray angle_b,
                        jfloatArray output) {
    if (angle_a == nullptr || angle_b == nullptr) {
        return;
    }

    float *p_angle_a = (float *) (env->GetFloatArrayElements(angle_a, JNI_FALSE));
    float *p_angle_b = (float *) (env->GetFloatArrayElements(angle_b, JNI_FALSE));

    VAngle a{p_angle_a[0], p_angle_a[1], p_angle_a[2]};
    VAngle b{p_angle_b[0], p_angle_b[1], p_angle_b[2]};
    std::vector<float> outs;
    VisionUtil::face_angle_optimal(a, b, outs);

    float *p_output = (float *) (env->GetFloatArrayElements(output, JNI_FALSE));
    p_output[0] = outs[0];
    p_output[1] = outs[1];
    env->SetFloatArrayRegion(output, 0, 2, p_output);
}

jboolean set_env(JNIEnv *env, jclass clazz, jstring envName, jstring envPath) {
    const char *env_name = env->GetStringUTFChars(envName, 0);
    const char *env_path = env->GetStringUTFChars(envPath, 0);
    VLOGI(TAG, "set env [%s]: %s", env_name, env_path);
    return setenv(env_name, env_path, 1 /*override*/) == 0;
}

// 函数注册 -----------------------------------------------------------------------------------------
/*
 * 定义函数映射表（是一个数组，可以同时定义多个函数的映射）
 * 参数1：Java 方法名
 * 参数2：方法描述符，也就是签名
 * 参数3：C++定义对应 Java native方法的函数名
 */
static JNINativeMethod jniNativeMethods[] = {
        {"init",
                                            "(ILjava/lang/String;Ljava/lang/Object;"
                                            "[Ljava/lang/Object;I[Ljava/lang/Object;I[Ljava/lang/Object;I"
                                            "Ljava/lang/Object;)V",
                                                                                            (void *) init},
        {"initModel",                       "(Ljava/lang/Object;)V",       (void *) initModel},
        {"initService",                     "(I)V",                        (void *) initService},
        {"initFaceBuffer",                  "(I[Ljava/lang/Object;I)V",    (void *) initFaceBuffer},
        {"initGestureBuffer",               "(I[Ljava/lang/Object;I)V",    (void *) initGestureBuffer},
        {"initBodyBuffer",                  "(I[Ljava/lang/Object;I)V",    (void *) initBodyBuffer},
        {"initFrameBuffer",                 "(ILjava/lang/Object;)V",      (void *) initFrameBuffer},

        {"initSingleFunctionResultData",    "(I[Ljava/lang/Object;ILjava/lang/Object;)V",
                                                                                            (void *) init_single_data},
        {"detect",                          "(I[BLcom/baidu/iov/vision/ability/util/PerformanceUtil;)Z",
                                                                                            (void *) detect},
        {"detectWithIndex",                 "(I[BLcom/baidu/iov/vision/ability/util/PerformanceUtil;)Z",
                                                                                            (void *) detect_with_index},
        {"detectWithIndex", "(I[BIILcom/baidu/iov/vision/ability/util/PerformanceUtil;)Z",
                                                                                            (void *) detect_with_index_frame_size},
        {"detect",                          "(I[B[F[[F[FLcom/baidu/iov/vision/ability/util/PerformanceUtil;)Z",
                                                                                            (void *) detect_with_buffer},
        {"getSwitch",                       "(IS)Z",                       (void *) get_switch},
        {"getSwitches",                     "(ILjava/util/HashMap;)V",     (void *) get_switches},
        {"setSwitch",                       "(ISZ)Z",                      (void *) set_switch},
        {"setSwitches",                     "(Ljava/util/Map;)V",          (void *) set_switches},
        {"compareFaceFeatures",             "([F[F)F",                     (void *) compare_face_features},
        {"getFrameResize",                  "([F[BSSSS[B)I",               (void *) crop_face},
        {"setConfig",                       "(IIF)Z",                      (void *) set_config},
        {"getConfig",                       "(II)F",                       (void *) get_config},
        {"setInitConfig",                   "(IIF)Z",                      (void *) set_init_config},
        {"getInitConfig",                   "(II)F",                       (void *) get_init_config},
        {"release",                         "(I)V",                        (void *) release},
        {"cleanAbilityTriggerAccumulative", "(IS)V",                       (void *) clean_ability_trigger_accumulative},
        {"toBytes",                         "([F[B)V",                     (void *) to_bytes},
        {"toFloats",                        "([B[F)V",                     (void *) to_floats},
        {"saveImage",                       "(Ljava/lang/String;[BII)V",   (void *) save_image},
        {"convertYuvToRgb",                 "([B[III)V",                   (void *) yuv_to_rgb},
        {"computeCosDifference",            "([F[F[F)V",                   (void *) face_angle_optimal},
        {"weightedAverage",                 "([F[F[F)Z",                   (void *) recent_update_feature},
        {"detectSingleFunction",            "(II[B[F)Z",                   (void *) detect_single_function},
        {"detectSingleFunction",            "(II[B[Ljava/lang/Object;ILjava/lang/Object;)Z",
                                                                                            (void *)detect_single_function_with_buffer},
        {"setEnv",                       "(Ljava/lang/String;Ljava/lang/String;)Z",  (void *) set_env}
};

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env = nullptr;
    if (vm->GetEnv((void **) &env, JNI_VERSION_1_4) != JNI_OK) {
        return JNI_ERR;
    }
    jclass clazz = env->FindClass(g_jni_class);
    if (clazz == nullptr) {
        return JNI_ERR;
    }
    jint ret = (env)->RegisterNatives(clazz, jniNativeMethods,
                                      sizeof(jniNativeMethods) / sizeof(JNINativeMethod));
    if (ret != JNI_OK) {
        return JNI_ERR;
    }
    return JNI_VERSION_1_4;
}

#ifdef __cplusplus
}
#endif
