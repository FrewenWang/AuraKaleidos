//
// Created by frewen on 25-2-24.
//
#include<vector>
#include<algorithm>
#include<climits>

using namespace std;



class Solution {
public:
  /**
   *  动态规划问题的一般步骤:
   * 1. 定义状态：确定问题的状态，将大问题分解为子问题，并确定子问题所对应的状态。
   * 2. 建立状态转移方程：根据题目要求或者问题的定义，建立子问题之间的递推关系。也就是简历递推的数学方程
   * 3. 初始化：确定初始状态的值。
   * 4. 递推求解：根据状态转移方程，自底向上地求解问题，直到得到最终的结果。
   * 5. 输出结果：根据最终的状态求解结果。
   */

  /**
   * 我们用 f[i][j] 表示从三角形顶部走到位置 (i,j) 的最小路径和。这里的位置 (i,j) 指的是三角形中第 i 行第 j 列（均从 0 开始编号）的位置。
   * 由于每一步只能移动到下一行「相邻的节点」上，因此要想走到位置 (i,j)，上一步就只能在位置 (i−1,j−1) 或者位置 (i−1,j)。
   * 我们在这两个位置中选择一个路径和较小的来进行转移，状态转移方程为：
   *                   f[i][j]=min(f[i−1][j−1],f[i−1][j])+c[i][j]
   *  其中 c[i][j] 表示位置 (i,j) 对应的元素值。
   *  注意第 i 行有 i+1 个元素，它们对应的 j 的范围为 [0,i]。当 j=0 或 j=i 时，上述状态转移方程中有一些项是没有意义的。例如当 j=0 时，f[i−1][j−1] 没有意义，因此状态转移方程为：
   *                   f[i][0]=f[i−1][0]+c[i][0]
   *  即当我们在第 i 行的最左侧时，我们只能从第 i−1 行的最左侧移动过来。当 j=i 时，f[i−1][j] 没有意义，因此状态转移方程为：
   *                    f[i][i]=f[i−1][i−1]+c[i][i]
   * 即当我们在第 i 行的最右侧时，我们只能从第 i−1 行的最右侧移动过来。
   * 最终的答案即为 f[n−1][0] 到 f[n−1][n−1] 中的最小值，其中 n 是三角形的行数。
   * 状态转移方程的边界条件是什么？由于我们已经去除了所有「没有意义」的状态，因此边界条件可以定为：
   *                     f[0][0]=c[0][0]
   * 即在三角形的顶部时，最小路径和就等于对应位置的元素值。这样一来，我们从 1 开始递增地枚举 i，并在 [0,i] 的范围内递增地枚举 j，就可以完成所有状态的计算。
   */
  int minimumTotal(vector<vector<int>>& triangle) {
    int n = triangle.size();
    // 构建数学方程
    vector<vector<int>> f(n, vector<int>(n));
    f[0][0] = triangle[0][0];
    for (int i = 1; i < n; ++i) {
      f[i][0] = f[i - 1][0] + triangle[i][0];
      //// 主要计算的就是如下的递推方程。
      for (int j = 1; j < i; ++j) {
        f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j];
      }
      f[i][i] = f[i - 1][i - 1] + triangle[i][i];
    }
    return *min_element(f[n - 1].begin(), f[n - 1].end());
  }
};