//
// Created by Frewen.Wong on 2022/4/23.
//

#include "CodeGeneratorCpp.h"
#include "lightbuffer/CommonUtil.h"
#include "lightbuffer/schema.h"
#include "aura/auralib/utils/FileUtil.h"
#include <sstream>

namespace aura::light_buffer {

// NOLINTNEXTLINE
static std::string auto_gen_tip =
        std::string("// Auto generated by the plain buffer compiler.\n") +
        "// PLEASE DO NOT EDIT!";

// NOLINTNEXTLINE
static std::string indent = "    "; // 4 spaces

CodeGeneratorCpp::CodeGeneratorCpp() {
    option = "cpp";
    help = "Generate C++ header and source.";
}

bool CodeGeneratorCpp::generate(const std::string &fileName,
                                const std::string &outDir,
                                std::shared_ptr<Schema> &schema) {
    bool ret = true;
    ret &= generateHeader(fileName, outDir, schema);
    ret &= generateSource(fileName, outDir, schema);
    return ret;
}

bool CodeGeneratorCpp::generateHeader(const std::string &fileName, const std::string &outDir,
                                      std::shared_ptr<Schema> &schema) {
    std::stringstream ss;
    ss << auto_gen_tip << std::endl                                     // 生成文件头部描述
       << "// source: " + fileName + ".proto" << std::endl              // 注释文件目录
       << std::endl
       << "#ifndef LIGHT_BUFFER_GENERATED_" << CommonUtil::toUpper(fileName) << "_H" << std::endl
       << "#define LIGHT_BUFFER_GENERATED_" << CommonUtil::toUpper(fileName) << "_H" << std::endl
       << std::endl
       << "#include <string>" << std::endl
       << "#include <unordered_map>" << std::endl
       << "#include <vector>" << std::endl
       << std::endl
       << "#include \"lightbuffer/BaseMessage.h\"" << std::endl
       << "#include \"lightbuffer/schema.h\"" << std::endl
       << std::endl
       << "namespace " << schema->packageName << " {" << std::endl
       << std::endl;
}

bool CodeGeneratorCpp::generateSource(const std::string &fileName, const std::string &outDir,
                                      std::shared_ptr<Schema> &schema) {
    std::stringstream ss;
    ss << auto_gen_tip << std::endl
       << "// source: " + fileName + ".proto" << std::endl
       << std::endl
       << "#include \"" << fileName << ".plain.h\"" << std::endl
       << "#include \"plainbuffer/serializer.h\"" << std::endl
       << "#include \"plainbuffer/util.h\"" << std::endl
       << std::endl
       << "using namespace plainbuffer;" << std::endl
       << std::endl
       << "namespace " << schema->packageName << " {" << std::endl
       << std::endl;

    for (const auto& msg_info : schema->messageList) {
        const auto& msg = msg_info.second;
        const auto& type_name = msg.typeName;
        ss << "const MessageDescriptor " << type_name << "::" << "_field_tables {" << std::endl;
        for (const auto& value : msg.valueList) {
            std::string type_str = value.typeNameStr;
            if (value.qualifier == Qualifier::REPEATED) {
                type_str += "_$v";
            }
            ss << indent << "{\"" << value.valueNameStr << "\", \"" << type_str << "\"}, " << std::endl;
        }
        ss << "};" << std::endl
           << std::endl;

        ss << type_name << "::" << type_name << "() {" << std::endl
           << indent << "clear();" << std::endl
           << "}" << std::endl
           << std::endl
           << "void " << type_name << "::clear() {" << std::endl;
        for (const auto& value : msg.valueList) {
            const auto& v_name = value.valueNameStr;
            ss << indent << "clear_" << v_name << "();" << std::endl;
        }
        ss << "}" << std::endl
           << std::endl;

        for (const auto& value : msg.valueList) {
            const auto& v_type = value.typeNameStr;
            const auto& v_name = value.valueNameStr;
            std::string cpp_type = v_type;
            if (EnumHelper::isPrimaryType(v_type)) {
                cpp_type = Keyword::castCppType(v_type);
            }

            if (value.qualifier != Qualifier::REPEATED) {
                if (v_type != "bytes") {
                    ss << "void " << type_name << "::set_" << v_name << "(const " << cpp_type << "& v) {" << std::endl
                       << indent << "_" << v_name << " = v;" << std::endl
                       << "}" << std::endl
                       << std::endl
                       << cpp_type << " " << type_name << "::" << v_name << "() const {" << std::endl
                       << indent << "return _" << v_name << ";" << std::endl
                       << "}" << std::endl
                       << std::endl;
                } else {
                    ss << "void " << type_name << "::set_" << v_name << "(" << cpp_type << "& v, size_t len) {" << std::endl
                       << indent << "_" << v_name << " = v;" << std::endl
                       << indent << "_" << v_name << "_len = len;" << std::endl
                       << "}" << std::endl
                       << std::endl
                       << "std::string " << type_name << "::" << v_name << "() const {" << std::endl
                       << indent << "return std::string(_" << v_name << ", _" << v_name << "_len);" << std::endl
                       << "}" << std::endl
                       << std::endl
                       << "const char* " << type_name << "::" << v_name << "_ptr() const {" << std::endl
                       << indent << "return _" << v_name << ";" << std::endl
                       << "}" << std::endl
                       << std::endl
                       << "size_t " << type_name << "::" << v_name << "_len() const {" << std::endl
                       << indent << "return (size_t)_" << v_name << "_len;" << std::endl
                       << "}" << std::endl
                       << std::endl;
                }

                if (EnumHelper::isPrimaryType(v_type)) {
                    ss << "void " << type_name << "::clear_" << v_name << "() {" << std::endl;
                    if (value.hasDefault) {
                        ss << indent << "_" << v_name << " = " << value.defaultValueStr << ";" << std::endl;
                    } else {
                        if (v_type != "bytes") {
                            ss << indent << "_" << v_name << " = " << cpp_type << "{};" << std::endl;
                        } else {
                            ss << indent << "_" << v_name << " = " << "nullptr;" << std::endl
                               << indent << "_" << v_name << "_len = 0;" << std::endl;
                        }
                    }
                    ss << "}" << std::endl
                       << std::endl;
                } else {
                    ss << "void " << type_name << "::clear_" << v_name << "() {" << std::endl
                       << indent << "_" << v_name << ".clear();" << std::endl
                       << "}" << std::endl
                       << std::endl
                       << cpp_type << "* " << type_name << "::mutable_" << v_name << "() {" << std::endl
                       << indent << "return &_" << v_name << ";" << std::endl
                       << "}" << std::endl
                       << std::endl;
                }
            } else {
                if (v_type != "bytes") {
                    if (!EnumHelper::isPrimaryType(v_type)) {
                        ss << cpp_type << "* " << type_name << "::add_" << v_name << "() {" << std::endl
                           << indent << "_" << v_name << ".emplace_back(" << cpp_type << "{});" << std::endl
                           << indent << "return &(_" << v_name << "[_" << v_name << ".size() - 1]);" << std::endl
                           << "}" << std::endl
                           << std::endl;
                    }
                    ss << "void " << type_name << "::add_" << v_name << "(const " << cpp_type << "& v) {" << std::endl
                       << indent << "_" << v_name << ".emplace_back(v);" << std::endl
                       << "}" << std::endl
                       << std::endl
                       << cpp_type << " " << type_name << "::" << v_name << "(int i) const {" << std::endl
                       << indent << "return _" << v_name << "[i];" << std::endl
                       << "}" << std::endl
                       << std::endl
                       << "const std::vector<" << cpp_type << ">& " << type_name << "::" << v_name << "() const {" << std::endl
                       << indent << "return _" << v_name << ";" << std::endl
                       << "}" << std::endl
                       << std::endl;
                } else {
                    ss << "void " << type_name << "::add_" << v_name << "(" << cpp_type << "& v, size_t len) {" << std::endl
                       << indent << "_" << v_name << ".emplace_back(v);" << std::endl
                       << indent << "_" << v_name << "_len.emplace_back(len);" << std::endl
                       << "}" << std::endl
                       << std::endl
                       << "std::string " << type_name << "::" << v_name << "(int i) const {" << std::endl
                       << indent << "return std::string(_" << v_name << "[i], _" << v_name << "_len[i]);" << std::endl
                       << "}" << std::endl
                       << std::endl
                       << "std::vector<std::string> " << type_name << "::" << v_name << "() const {" << std::endl
                       << indent << "std::vector<std::string> s;" << std::endl
                       << indent << "for (auto i = 0; i < _" << v_name << ".size(); ++i) {" << std::endl
                       << indent << indent << "s.emplace_back(_" << v_name << "[i], _" << v_name << "_len[i]);" << std::endl
                       << indent << "}" << std::endl
                       << indent << "return s;" << std::endl
                       << "}" << std::endl
                       << std::endl
                       << "const char* " << type_name << "::" << v_name << "_ptr(int i) const {" << std::endl
                       << indent << "return _" << v_name << "[i];" << std::endl
                       << "}" << std::endl
                       << std::endl
                       << "size_t " << type_name << "::" << v_name << "_len(int i) const {" << std::endl
                       << indent << "return (size_t)_" << v_name << "_len[i];" << std::endl
                       << "}" << std::endl
                       << std::endl;
                }

                ss << "size_t " << type_name << "::" << v_name << "_size() const {" << std::endl
                   << indent << "return _" << v_name << ".size();" << std::endl
                   << "}" << std::endl
                   << std::endl
                   << "void " << type_name << "::clear_" << v_name << "() {" << std::endl
                   << indent << "_" << v_name << ".clear();" << std::endl
                   << "}" << std::endl
                   << std::endl;
            }

            ss << "bool " << type_name << "::has_" << v_name << "() const {" << std::endl
               << indent << "return true;" << std::endl
               << "}" << std::endl
               << std::endl;
        }

        // internal_serialize
        ss << "bool " << type_name << "::internal_serialize(char* data, int size) const {" << std::endl
           << indent << "if (data == nullptr) {" << std::endl
           << indent << indent << "return false;" << std::endl
           << indent << "}" << std::endl
           << indent << "int bytes_size = static_cast<int>(internal_bytes_size());" << std::endl
           << indent << "if (bytes_size > size) {" << std::endl
           << indent << indent << "return false;" << std::endl
           << indent << "}" << std::endl
           << std::endl
           << indent << "int offset = 0;" << std::endl;

        for (const auto& value : msg.valueList) {
            const auto& v_type = value.typeNameStr;
            const auto& v_name = value.valueNameStr;
            std::string cpp_type = v_type;
            if (value.qualifier == Qualifier::REPEATED) {
                if (v_type != "bytes") {
                    ss << indent << "if (!plainbuffer::Serializer::serialize_vector(_" << v_name
                       << ", data, size, offset)) {" << std::endl
                       << indent << indent << "return false;" << std::endl
                       << indent << "}" << std::endl;
                } else {
                    ss << indent << "if (!plainbuffer::Serializer::serialize_vector_bytes(_" << v_name
                       << ", _" << v_name << "_len, data, size, offset)) {" << std::endl
                       << indent << indent << "return false;" << std::endl
                       << indent << "}" << std::endl;
                }
            } else {
                if (value.valueType == ValueType::PRIMARY_TYPE) {
                    cpp_type = Keyword::castCppType(v_type);
                    std::string type_tag = (v_type == "string" ? "string" : cpp_type);
                    if (v_type != "bytes") {
                        ss << indent << "if (!plainbuffer::Serializer::serialize_" << type_tag << "(_" << v_name
                           << ", data, size, offset)) {" << std::endl
                           << indent << indent << "return false;" << std::endl
                           << indent << "}" << std::endl;
                    } else {
                        ss << indent << "if (!plainbuffer::Serializer::serialize_bytes" << "(_" << v_name
                           << ", _" << v_name << "_len, data, size, offset)) {" << std::endl
                           << indent << indent << "return false;" << std::endl
                           << indent << "}" << std::endl;
                    }
                } else {
                    ss << indent << "if (!plainbuffer::Serializer::serialize_message(_" << v_name
                       << ", data, size, offset)) {" << std::endl
                       << indent << indent << "return false;" << std::endl
                       << indent << "}" << std::endl;
                }
            }
        }
        ss << indent << "return true;" << std::endl
           << "}" << std::endl
           << std::endl;

        // internal_deserialize
        ss << "bool " << type_name << "::internal_deserialize(const char* data, int size) {" << std::endl
           << indent << "if (data == nullptr) {" << std::endl
           << indent << indent << "return false;" << std::endl
           << indent << "}" << std::endl
           << std::endl
           << indent << "int offset = 0;" << std::endl;

        for (const auto& value : msg.valueList) {
            const auto& v_type = value.typeNameStr;
            const auto& v_name = value.valueNameStr;
            std::string cpp_type = v_type;
            if (value.qualifier == Qualifier::REPEATED) {
                if (v_type != "bytes") {
                    ss << indent << "if (!plainbuffer::Deserializer::deserialize_vector(_" << v_name
                       << ", data, size, offset)) {" << std::endl
                       << indent << indent << "return false;" << std::endl
                       << indent << "}" << std::endl;
                } else {
                    ss << indent << "if (!plainbuffer::Deserializer::deserialize_vector_bytes(_" << v_name
                       << ", _" << v_name << "_len, data, size, offset)) {" << std::endl
                       << indent << indent << "return false;" << std::endl
                       << indent << "}" << std::endl;
                }
            } else {
                if (value.valueType == ValueType::PRIMARY_TYPE) {
                    cpp_type = Keyword::castCppType(v_type);
                    std::string type_tag = (v_type == "string" ? "string" : cpp_type);
                    if (v_type != "bytes") {
                        ss << indent << "if (!plainbuffer::Deserializer::deserialize_" << type_tag << "(_" << v_name
                           << ", data, size, offset)) {" << std::endl
                           << indent << indent << "return false;" << std::endl
                           << indent << "}" << std::endl;
                    } else {
                        ss << indent << "if (!plainbuffer::Deserializer::deserialize_bytes(_" << v_name
                           << ", _" << v_name << "_len, data, size, offset)) {" << std::endl
                           << indent << indent << "return false;" << std::endl
                           << indent << "}" << std::endl;
                    }

                } else {
                    ss << indent << "if (!plainbuffer::Deserializer::deserialize_message(_" << v_name
                       << ", data, size, offset)) {" << std::endl
                       << indent << indent << "return false;" << std::endl
                       << indent << "}" << std::endl;
                }
            }

        }
        ss << indent << "return true;" << std::endl
           << "}" << std::endl
           << std::endl;

        // internal_parse_from_descriptor
        ss << "bool " << type_name << "::internal_parse_from_descriptor(DataDescriptorMap& data_map, const std::string& key) {" << std::endl
           << indent << "clear();" << std::endl
           << std::endl
           << indent << "if (data_map.size() == 0 || data_map.find(key) == data_map.end()) {" << std::endl
           << indent << indent << "return false;" << std::endl
           << indent << "}" << std::endl
           << std::endl;
        const auto& lower_type_name = Util::to_lower(type_name);
        ss << indent << "auto& desc_" << lower_type_name << " = data_map[key];" << std::endl
           << std::endl;

        for (const auto& value : msg.value_list) {
            const auto& v_type = value.type_name_str;
            const auto& v_name = value.value_name_str;
            if (v_type == "bytes") {
                continue; // bytes data is ignored for text-format
            }
            std::string cpp_type = v_type;
            if (value.qualifier != Qualifier::REPEATED) {
                cpp_type = Keyword::cast_cpp_type(v_type);
                ss << indent << "if (desc_" << lower_type_name << ".find(\"" << v_name << "\") != desc_" << lower_type_name << ".end()) {" << std::endl
                   << indent << indent << "auto& datalist = desc_" << lower_type_name << "[\"" << v_name << "\"];" << std::endl
                   << indent << indent << "if (!datalist.empty()) {" << std::endl;
                if (value.value_type == ValueType::PRIMARY_TYPE) {
                    ss << indent << indent << indent << "_" << v_name << " = ";
                    if (v_type != "string") {
                        ss << "Util::parse_from_str<" << cpp_type << ">(datalist[0]);" << std::endl;
                    } else {
                        ss << "datalist[0];" << std::endl;
                    }

                } else {
                    ss << indent << indent << indent << "_" << v_name << ".ParseFromDescriptor(data_map, key + \"" << v_type << "0\");" << std::endl;
                }
                ss << indent << indent << "}" << std::endl
                   << indent << "}" << std::endl;
            } else {
                ss << indent << "if (desc_" << lower_type_name << ".find(\"" << v_name << "\") != desc_" << lower_type_name << ".end()) {" << std::endl
                   << indent << indent << "auto& datalist = desc_" << lower_type_name << "[\"" << v_name << "\"];" << std::endl;
                if (value.value_type == ValueType::PRIMARY_TYPE) {
                    cpp_type = Keyword::cast_cpp_type(v_type);
                    ss << indent << indent << "for (auto& s : datalist) {" << std::endl
                       << indent << indent << indent << "_" << v_name << ".emplace_back(";
                    if (v_type != "string") {
                        ss << "Util::parse_from_str<" << cpp_type << ">(s));" << std::endl;
                    } else {
                        ss << "s);" << std::endl;
                    }
                } else {
                    const auto& lower_v_type = Util::to_lower(v_type);
                    ss << indent << indent << "if (!datalist.empty()) {" << std::endl
                       << indent << indent << indent << "int cnt = std::stoi(datalist[0]);" << std::endl
                       << indent << indent << indent << "for (int i = 0; i < cnt; ++i) {" << std::endl
                       << indent << indent << indent << indent << v_type << " tmp;" << std::endl
                       << indent << indent << indent << indent << "tmp.ParseFromDescriptor(data_map, key + \"" << v_type << "\" + std::to_string(i));" << std::endl
                       << indent << indent << indent << indent << "_" << v_name << ".emplace_back(std::move(tmp));" << std::endl
                       << indent << indent << indent << "}" << std::endl;
                }
                ss << indent << indent << "}" << std::endl
                   << indent << "}" << std::endl
                   << std::endl;
            }
        }
        ss << indent << "return true;" << std::endl
           << "}" << std::endl
           << std::endl;

        // internal_bytes_size
        ss << "size_t " << type_name << "::internal_bytes_size() const {" << std::endl
           << indent << "size_t size = 0;" << std::endl;
        for (const auto& value : msg.value_list) {
            const auto& v_type = value.type_name_str;
            const auto& v_name = value.value_name_str;
            auto q_type = static_cast<Qualifier>(value.qualifier);
            std::string cpp_type = v_type;
            if (EnumHelper::is_primary_type(v_type)) {
                cpp_type = Keyword::cast_cpp_type(v_type);
                if (q_type != Qualifier::REPEATED) {
                    if (v_type == "string") {
                        ss << indent << "size += sizeof(int) + _" << v_name << ".size();" << std::endl;
                    } else if (v_type == "bytes") {
                        ss << indent << "size += sizeof(int) + _" << v_name << "_len;" << std::endl;
                    } else {
                        ss << indent << "size += sizeof(" << cpp_type << ");" << std::endl;
                    }
                } else {
                    ss << indent << "size += sizeof(int);" << std::endl
                       << indent << "for (size_t i = 0; i < _" << v_name << ".size(); ++i) {" << std::endl;
                    if (v_type == "string") {
                        ss << indent << indent << "size += sizeof(int) + _" << v_name << "[i].size();" << std::endl;
                    } else if (v_type == "bytes") {
                        ss << indent << indent << "size += sizeof(int) + _" << v_name << "_len[i];" << std::endl;
                    } else {
                        ss << indent << indent << "size += sizeof(" << cpp_type << ");" << std::endl;
                    }
                    ss << indent << "}" << std::endl;
                }
            } else {
                if (q_type != Qualifier::REPEATED) {
                    ss << indent << "size += _" << v_name << ".ByteSizeLong();" << std::endl;
                } else {
                    ss << indent << "size += sizeof(int);" << std::endl;
                    ss << indent << "for (const auto& m : _" << v_name << ") {" << std::endl
                       << indent << indent << "size += m.ByteSizeLong();" << std::endl
                       << indent << "}" << std::endl;
                }
            }
        }
        ss << indent << "return size;" << std::endl
           << "}" << std::endl
           << std::endl;

        // internal_get_descriptor
        ss << "MessageDescriptorMap " << type_name << "::internal_get_descriptor() const {" << std::endl;
        ss << indent << "MessageDescriptorMap map;" << std::endl
           << indent << "map[\"" << type_name << "\"] = _field_tables;" << std::endl;
        for (const auto& value : msg.valueList) {
            const auto& v_type = value.typeNameStr;
            const auto& v_name = value.valueNameStr;
            if (value.valueType == ValueType::DEFINED_TYPE) {
                ss << indent << v_type << " dummy_" << v_type  << "{};" << std::endl
                   << indent << "auto desc_" << v_type << " = dummy_" << v_type << ".GetDescriptor();" << std::endl
                   << indent << "for (auto& m : desc_" << v_type << ") {" << std::endl
                   << indent << indent << "map[m.first] = m.second;" << std::endl
                   << indent << "}" << std::endl;
            }
        }
        ss << indent << "return map;" << std::endl
           << "}" << std::endl
           << std::endl;

        // internal_get_typename
        ss << "std::string " << type_name << "::internal_get_typename() const {" << std::endl
           << indent << "return \"" << type_name << "\";" << std::endl
           << "}" << std::endl
           << std::endl;
    }

    ss << "} // namespace " << schema->packageName << std::endl;

    std::string dir = outDir;
    if (!dir.empty() && dir[dir.size() - 1] == '/') {
        dir = dir.substr(0, dir.size() - 1);
    }
    FileUtil::save_file(dir + "/" + file_name + ".plain.cpp", ss.str());
    return false;
}

}// namespace lightbuffer
