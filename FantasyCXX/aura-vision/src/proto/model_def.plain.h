// Auto generated by the plain buffer compiler.
// PLEASE DO NOT EDIT!
// source: model_def.proto

#ifndef PLAIN_BUFFER_GENERATED_MODEL_DEF_H
#define PLAIN_BUFFER_GENERATED_MODEL_DEF_H

#include <string>
#include <unordered_map>
#include <vector>

#include "lightbuffer/message_base.h"
#include "lightbuffer/schema.h"

namespace aura::vision {

class ModelFlag : public light_buffer::MessageBase {
public:
    ModelFlag();
    ~ModelFlag() override = default;
    void clear();

public:
    void set_magic(const std::string&);
    std::string magic() const;
    bool has_magic() const;
    void clear_magic();
private:
    std::string _magic;
    static constexpr int OFFSET_MAGIC = 1;
    static constexpr int QTAG_MAGIC = 1;
    static constexpr int TTAG_MAGIC = 0;

public:
    void set_model_cnt(const int&);
    int model_cnt() const;
    bool has_model_cnt() const;
    void clear_model_cnt();
private:
    int _model_cnt;
    static constexpr int OFFSET_MODEL_CNT = 2;
    static constexpr int QTAG_MODEL_CNT = 1;
    static constexpr int TTAG_MODEL_CNT = 0;

public:
    void set_encrypt_type(const int&);
    int encrypt_type() const;
    bool has_encrypt_type() const;
    void clear_encrypt_type();
private:
    int _encrypt_type;
    static constexpr int OFFSET_ENCRYPT_TYPE = 3;
    static constexpr int QTAG_ENCRYPT_TYPE = 1;
    static constexpr int TTAG_ENCRYPT_TYPE = 0;

protected:
    bool InternalSerialize(char* data, int size) const override;
    bool InternalDeserialize(const char* data, int size) override;
    bool InternalParseFromDescriptor(light_buffer::DataDescriptorMap& data_map, const std::string& key) override;
    size_t InternalBytesSize() const override;
    light_buffer::MessageDescriptorMap InternalGetDescriptor() const override;
    std::string InternalGetTypeName() const override;

private:
    static const light_buffer::MessageDescriptor _field_tables;
};

class MemBlock : public light_buffer::MessageBase {
public:
    MemBlock();
    ~MemBlock() override = default;
    void clear();

public:
    void set_len(const int&);
    int len() const;
    bool has_len() const;
    void clear_len();
private:
    int _len;
    static constexpr int OFFSET_LEN = 1;
    static constexpr int QTAG_LEN = 1;
    static constexpr int TTAG_LEN = 0;

public:
    void set_offset(const int&);
    int offset() const;
    bool has_offset() const;
    void clear_offset();
private:
    int _offset;
    static constexpr int OFFSET_OFFSET = 2;
    static constexpr int QTAG_OFFSET = 1;
    static constexpr int TTAG_OFFSET = 0;

public:
    void set_encrypted(const bool&);
    bool encrypted() const;
    bool has_encrypted() const;
    void clear_encrypted();
private:
    bool _encrypted;
    static constexpr int OFFSET_ENCRYPTED = 3;
    static constexpr int QTAG_ENCRYPTED = 1;
    static constexpr int TTAG_ENCRYPTED = 0;

protected:
    bool InternalSerialize(char* data, int size) const override;
    bool InternalDeserialize(const char* data, int size) override;
    bool InternalParseFromDescriptor(light_buffer::DataDescriptorMap& data_map, const std::string& key) override;
    size_t InternalBytesSize() const override;
    light_buffer::MessageDescriptorMap InternalGetDescriptor() const override;
    std::string InternalGetTypeName() const override;

private:
    static const light_buffer::MessageDescriptor _field_tables;
};

class ModelDesc : public light_buffer::MessageBase {
public:
    ModelDesc();
    ~ModelDesc() override = default;
    void clear();

public:
    void set_model_id(const int&);
    int model_id() const;
    bool has_model_id() const;
    void clear_model_id();
private:
    int _model_id;
    static constexpr int OFFSET_MODEL_ID = 1;
    static constexpr int QTAG_MODEL_ID = 1;
    static constexpr int TTAG_MODEL_ID = 0;

public:
    void set_infer_type(const int&);
    int infer_type() const;
    bool has_infer_type() const;
    void clear_infer_type();
private:
    int _infer_type;
    static constexpr int OFFSET_INFER_TYPE = 2;
    static constexpr int QTAG_INFER_TYPE = 1;
    static constexpr int TTAG_INFER_TYPE = 0;

public:
    MemBlock* add_mem_blocks();
    void add_mem_blocks(const MemBlock&);
    MemBlock mem_blocks(int) const;
    const std::vector<MemBlock>& mem_blocks() const;
    bool has_mem_blocks() const;
    size_t mem_blocks_size() const;
    void clear_mem_blocks();
private:
    std::vector<MemBlock> _mem_blocks;
    static constexpr int OFFSET_MEM_BLOCKS = 3;
    static constexpr int QTAG_MEM_BLOCKS = 2;
    static constexpr int TTAG_MEM_BLOCKS = 1;

public:
    void set_dtype(const int&);
    int dtype() const;
    bool has_dtype() const;
    void clear_dtype();
private:
    int _dtype;
    static constexpr int OFFSET_DTYPE = 11;
    static constexpr int QTAG_DTYPE = 0;
    static constexpr int TTAG_DTYPE = 0;

public:
    void set_version(const std::string&);
    std::string version() const;
    bool has_version() const;
    void clear_version();
private:
    std::string _version;
    static constexpr int OFFSET_VERSION = 12;
    static constexpr int QTAG_VERSION = 0;
    static constexpr int TTAG_VERSION = 0;

public:
    void set_device(const int&);
    int device() const;
    bool has_device() const;
    void clear_device();
private:
    int _device;
    static constexpr int OFFSET_DEVICE = 13;
    static constexpr int QTAG_DEVICE = 0;
    static constexpr int TTAG_DEVICE = 0;

public:
    void set_enable_omp(const bool&);
    bool enable_omp() const;
    bool has_enable_omp() const;
    void clear_enable_omp();
private:
    bool _enable_omp;
    static constexpr int OFFSET_ENABLE_OMP = 14;
    static constexpr int QTAG_ENABLE_OMP = 0;
    static constexpr int TTAG_ENABLE_OMP = 0;

public:
    void setVersionCode(int versionCode);
    int versionCode() const;
    void clearVersionCode();
private:
    int _version_code = 0;

public:
    void setExtends(std::string extends);
    std::string extends() const;
    void clearExtends();
private:
    std::string _extends;

protected:
    bool InternalSerialize(char* data, int size) const override;
    bool InternalDeserialize(const char* data, int size) override;
    bool InternalParseFromDescriptor(light_buffer::DataDescriptorMap& data_map, const std::string& key) override;
    size_t InternalBytesSize() const override;
    light_buffer::MessageDescriptorMap InternalGetDescriptor() const override;
    std::string InternalGetTypeName() const override;

private:
    static const light_buffer::MessageDescriptor _field_tables;
};

class ModelHeader : public light_buffer::MessageBase {
public:
    ModelHeader();
    ~ModelHeader() override = default;
    void clear();

public:
    ModelDesc* add_model_descs();
    void add_model_descs(const ModelDesc&);
    ModelDesc model_descs(int) const;
    const std::vector<ModelDesc>& model_descs() const;
    bool has_model_descs() const;
    size_t model_descs_size() const;
    void clear_model_descs();
private:
    std::vector<ModelDesc> _model_descs;
    static constexpr int OFFSET_MODEL_DESCS = 1;
    static constexpr int QTAG_MODEL_DESCS = 2;
    static constexpr int TTAG_MODEL_DESCS = 1;

protected:
    bool InternalSerialize(char* data, int size) const override;
    bool InternalDeserialize(const char* data, int size) override;
    bool InternalParseFromDescriptor(light_buffer::DataDescriptorMap& data_map, const std::string& key) override;
    size_t InternalBytesSize() const override;
    light_buffer::MessageDescriptorMap InternalGetDescriptor() const override;
    std::string InternalGetTypeName() const override;

private:
    static const light_buffer::MessageDescriptor _field_tables;
};

class ModelData : public light_buffer::MessageBase {
public:
    ModelData();
    ~ModelData() override = default;
    void clear();

public:
    void set_model_flag(const ModelFlag&);
    ModelFlag model_flag() const;
    bool has_model_flag() const;
    void clear_model_flag();
    ModelFlag* mutable_model_flag();
private:
    ModelFlag _model_flag;
    static constexpr int OFFSET_MODEL_FLAG = 1;
    static constexpr int QTAG_MODEL_FLAG = 1;
    static constexpr int TTAG_MODEL_FLAG = 1;

public:
    void set_model_header(const char*&, size_t);
    std::string model_header() const;
    const char* model_header_ptr() const;
    size_t model_header_len() const;
    bool has_model_header() const;
    void clear_model_header();
private:
    const char* _model_header;
    size_t _model_header_len;
    static constexpr int OFFSET_MODEL_HEADER = 2;
    static constexpr int QTAG_MODEL_HEADER = 1;
    static constexpr int TTAG_MODEL_HEADER = 0;

public:
    void set_model_blob(const char*&, size_t);
    std::string model_blob() const;
    const char* model_blob_ptr() const;
    size_t model_blob_len() const;
    bool has_model_blob() const;
    void clear_model_blob();
private:
    const char* _model_blob;
    size_t _model_blob_len;
    static constexpr int OFFSET_MODEL_BLOB = 3;
    static constexpr int QTAG_MODEL_BLOB = 1;
    static constexpr int TTAG_MODEL_BLOB = 0;

protected:
    bool InternalSerialize(char* data, int size) const override;
    bool InternalDeserialize(const char* data, int size) override;
    bool InternalParseFromDescriptor(light_buffer::DataDescriptorMap& data_map, const std::string& key) override;
    size_t InternalBytesSize() const override;
    light_buffer::MessageDescriptorMap InternalGetDescriptor() const override;
    std::string InternalGetTypeName() const override;

private:
    static const light_buffer::MessageDescriptor _field_tables;
};

} // namespace vision

#endif // PLAIN_BUFFER_GENERATED_MODEL_DEF_H
