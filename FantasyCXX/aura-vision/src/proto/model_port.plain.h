// Auto generated by the plain buffer compiler.
// PLEASE DO NOT EDIT!
// source: model_port.proto

#ifndef PLAIN_BUFFER_GENERATED_MODEL_PORT_H
#define PLAIN_BUFFER_GENERATED_MODEL_PORT_H

#include <string>
#include <unordered_map>
#include <vector>

#include "lightbuffer/message_base.h"
#include "lightbuffer/schema.h"

namespace aura::vision {
class TensorShape : public light_buffer::MessageBase {
public:
    TensorShape();

    ~TensorShape() override = default;

    void clear();

public:
    void set_w(const int &);

    int w() const;

    bool has_w() const;

    void clear_w();

private:
    int _w;
    static constexpr int OFFSET_W = 1;
    static constexpr int QTAG_W = 1;
    static constexpr int TTAG_W = 0;

public:
    void set_h(const int &);

    int h() const;

    bool has_h() const;

    void clear_h();

private:
    int _h;
    static constexpr int OFFSET_H = 2;
    static constexpr int QTAG_H = 1;
    static constexpr int TTAG_H = 0;

public:
    void set_c(const int &);

    int c() const;

    bool has_c() const;

    void clear_c();

private:
    int _c;
    static constexpr int OFFSET_C = 3;
    static constexpr int QTAG_C = 1;
    static constexpr int TTAG_C = 0;

protected:
    bool InternalSerialize(char *data, int size) const override;

    bool InternalDeserialize(const char *data, int size) override;

    bool InternalParseFromDescriptor(light_buffer::DataDescriptorMap &data_map, const std::string &key) override;

    size_t InternalBytesSize() const override;

    light_buffer::MessageDescriptorMap InternalGetDescriptor() const override;

    std::string InternalGetTypeName() const override;

private:
    static const light_buffer::MessageDescriptor _field_tables;
};

class ModelInput : public light_buffer::MessageBase {
public:
    ModelInput();

    ~ModelInput() override = default;

    void clear();

public:
    void set_name(const std::string &);

    std::string name() const;

    bool has_name() const;

    void clear_name();

private:
    std::string _name;
    static constexpr int OFFSET_NAME = 1;
    static constexpr int QTAG_NAME = 0;
    static constexpr int TTAG_NAME = 0;

public:
    void set_index(const int &);

    int index() const;

    bool has_index() const;

    void clear_index();

private:
    int _index;
    static constexpr int OFFSET_INDEX = 2;
    static constexpr int QTAG_INDEX = 0;
    static constexpr int TTAG_INDEX = 0;

public:
    void set_shape(const TensorShape &);

    TensorShape shape() const;

    bool has_shape() const;

    void clear_shape();

    TensorShape *mutable_shape();

private:
    TensorShape _shape;
    static constexpr int OFFSET_SHAPE = 3;
    static constexpr int QTAG_SHAPE = 0;
    static constexpr int TTAG_SHAPE = 1;

protected:
    bool InternalSerialize(char *data, int size) const override;

    bool InternalDeserialize(const char *data, int size) override;

    bool InternalParseFromDescriptor(light_buffer::DataDescriptorMap &data_map, const std::string &key) override;

    size_t InternalBytesSize() const override;

    light_buffer::MessageDescriptorMap InternalGetDescriptor() const override;

    std::string InternalGetTypeName() const override;

private:
    static const light_buffer::MessageDescriptor _field_tables;
};

class PortDesc : public light_buffer::MessageBase {
public:
    PortDesc();

    ~PortDesc() override = default;

    void clear();

public:
    void set_ability(const std::string &);

    std::string ability() const;

    bool has_ability() const;

    void clear_ability();

private:
    std::string _ability;
    static constexpr int OFFSET_ABILITY = 1;
    static constexpr int QTAG_ABILITY = 1;
    static constexpr int TTAG_ABILITY = 0;

public:
    void set_model_version(const std::string &);

    std::string model_version() const;

    bool has_model_version() const;

    void clear_model_version();

private:
    std::string _model_version;
    static constexpr int OFFSET_MODEL_VERSION = 2;
    static constexpr int QTAG_MODEL_VERSION = 0;
    static constexpr int TTAG_MODEL_VERSION = 0;

public:
    ModelInput *add_input();

    void add_input(const ModelInput &);

    ModelInput input(int) const;

    const std::vector<ModelInput> &input() const;

    bool has_input() const;

    size_t input_size() const;

    void clear_input();

private:
    std::vector<ModelInput> _input;
    static constexpr int OFFSET_INPUT = 3;
    static constexpr int QTAG_INPUT = 2;
    static constexpr int TTAG_INPUT = 1;

public:
    void add_output(const std::string &);

    std::string output(int) const;

    const std::vector<std::string> &output() const;

    bool has_output() const;

    size_t output_size() const;

    void clear_output();

private:
    std::vector<std::string> _output;
    static constexpr int OFFSET_OUTPUT = 4;
    static constexpr int QTAG_OUTPUT = 2;
    static constexpr int TTAG_OUTPUT = 0;

public:
    void add_snpe_output(const std::string &);

    std::string snpe_output(int) const;

    const std::vector<std::string> &snpe_output() const;

    bool has_snpe_output() const;

    size_t snpe_output_size() const;

    void clear_snpe_output();

private:
    std::vector<std::string> _snpe_output;
    static constexpr int OFFSET_SNPE_OUTPUT = 5;
    static constexpr int QTAG_SNPE_OUTPUT = 2;
    static constexpr int TTAG_SNPE_OUTPUT = 0;

public:
    void add_qnn_output(const std::string &);

    std::string qnn_output(int) const;

    const std::vector<std::string> &qnn_output() const;

    bool has_qnn_output() const;

    size_t qnn_output_size() const;

    void clear_qnn_output();

private:
    std::vector<std::string> _qnn_output;
    static constexpr int OFFSET_QNN_OUTPUT = 6;
    static constexpr int QTAG_QNN_OUTPUT = 2;
    static constexpr int TTAG_QNN_OUTPUT = 0;

protected:
    bool InternalSerialize(char *data, int size) const override;

    bool InternalDeserialize(const char *data, int size) override;

    bool InternalParseFromDescriptor(light_buffer::DataDescriptorMap &data_map, const std::string &key) override;

    size_t InternalBytesSize() const override;

    light_buffer::MessageDescriptorMap InternalGetDescriptor() const override;

    std::string InternalGetTypeName() const override;

private:
    static const light_buffer::MessageDescriptor _field_tables;
};

class ModelPort : public light_buffer::MessageBase {
public:
    ModelPort();

    ~ModelPort() override = default;

    void clear();

public:
    PortDesc *add_model_port();

    void add_model_port(const PortDesc &);

    PortDesc model_port(int) const;

    const std::vector<PortDesc> &model_port() const;

    bool has_model_port() const;

    size_t model_port_size() const;

    void clear_model_port();

private:
    std::vector<PortDesc> _model_port;
    static constexpr int OFFSET_MODEL_PORT = 1;
    static constexpr int QTAG_MODEL_PORT = 2;
    static constexpr int TTAG_MODEL_PORT = 1;

protected:
    bool InternalSerialize(char *data, int size) const override;

    bool InternalDeserialize(const char *data, int size) override;

    bool InternalParseFromDescriptor(light_buffer::DataDescriptorMap &data_map, const std::string &key) override;

    size_t InternalBytesSize() const override;

    light_buffer::MessageDescriptorMap InternalGetDescriptor() const override;

    std::string InternalGetTypeName() const override;

private:
    static const light_buffer::MessageDescriptor _field_tables;
};
} // namespace aura::vision

#endif // PLAIN_BUFFER_GENERATED_MODEL_PORT_H
